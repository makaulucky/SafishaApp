"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateInlineStyle = generateInlineStyle;

var _tsDedent = _interopRequireDefault(require("ts-dedent"));

var _getExpoFontMapEntry = require("./getExpoFontMapEntry");

var _getLocalFontName = require("./getLocalFontName");

var _templateObject;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function generateInlineStyle(fontFace) {
  return (0, _tsDedent.default)(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n    @font-face {\n      font-family: '", "';\n      font-style: ", ";\n      font-weight: ", ";\n      font-display: auto;\n      src: ", ";\n    }"])), fontFace.fontFamily, fontFace.fontStyle, fontFace.fontWeight, extractSourceString(fontFace));
}

function extractSourceString(fontFace) {
  const fontName = (0, _getLocalFontName.getLocalFontName)(fontFace);
  const remoteUrl = (0, _getExpoFontMapEntry.getExpoFontMapEntry)(fontFace);

  if (remoteUrl) {
    return "local('".concat(fontFace.fontFamily, "'), local('").concat(fontName, "'), url(").concat(remoteUrl.url, ") format('").concat(remoteUrl.format, "')");
  } else {
    return "local('".concat(fontFace.fontFamily, "'), local('").concat(fontName, "');");
  }
}
//# sourceMappingURL=generateInlineStyle.js.map